(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[662],{2036:function(e,t,r){"use strict";r.d(t,{V:function(){return h}});var n,i,o=r(9678),a=r(4979),s=r(4812),l=r(2985),c=r(5391);let u=new l.Vector3,d=new l.Vector3,m=new l.Vector3;function defaultCalculatePosition(e,t,r){let n=u.setFromMatrixPosition(e.matrixWorld);n.project(t);let i=r.width/2,o=r.height/2;return[n.x*i+i,-(n.y*o)+o]}let epsilon=e=>1e-10>Math.abs(e)?0:e;function getCSSMatrix(e,t,r=""){let n="matrix3d(";for(let r=0;16!==r;r++)n+=epsilon(t[r]*e.elements[r])+(15!==r?",":")");return r+n}let x=(n=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>getCSSMatrix(e,n)),f=(i=e=>[1/e,1/e,1/e,1,-1/e,-1/e,-1/e,-1,1/e,1/e,1/e,1,1,1,1,1],(e,t)=>getCSSMatrix(e,i(t),"translate(-50%,-50%)")),h=a.forwardRef(({children:e,eps:t=.001,style:r,className:n,prepend:i,center:h,fullscreen:p,portal:g,distanceFactor:v,sprite:b=!1,transform:y=!1,occlude:M,onOcclude:j,castShadow:P,receiveShadow:w,material:E,geometry:S,zIndexRange:W=[16777271,0],calculatePosition:C=defaultCalculatePosition,as:$="div",wrapperClass:z,pointerEvents:F="auto",...N},R)=>{let{gl:T,camera:V,scene:k,size:A,raycaster:I,events:_,viewport:O}=(0,c.z)(),[H]=a.useState(()=>document.createElement($)),D=a.useRef(),L=a.useRef(null),G=a.useRef(0),Y=a.useRef([0,0]),Z=a.useRef(null),q=a.useRef(null),U=(null==g?void 0:g.current)||_.connected||T.domElement.parentNode,X=a.useRef(null),B=a.useRef(!1),J=a.useMemo(()=>{var e;return M&&"blending"!==M||Array.isArray(M)&&M.length&&(e=M[0])&&"object"==typeof e&&"current"in e},[M]);a.useLayoutEffect(()=>{let e=T.domElement;M&&"blending"===M?(e.style.zIndex=`${Math.floor(W[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)},[M]),a.useLayoutEffect(()=>{if(L.current){let e=D.current=s.createRoot(H);if(k.updateMatrixWorld(),y)H.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{let e=C(L.current,V,A);H.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return U&&(i?U.prepend(H):U.appendChild(H)),()=>{U&&U.removeChild(H),e.unmount()}}},[U,y]),a.useLayoutEffect(()=>{z&&(H.className=z)},[z]);let K=a.useMemo(()=>y?{position:"absolute",top:0,left:0,width:A.width,height:A.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:h?"translate3d(-50%,-50%,0)":"none",...p&&{top:-A.height/2,left:-A.width/2,width:A.width,height:A.height},...r},[r,h,p,A,y]),Q=a.useMemo(()=>({position:"absolute",pointerEvents:F}),[F]);a.useLayoutEffect(()=>{var t,i;B.current=!1,y?null==(t=D.current)||t.render(a.createElement("div",{ref:Z,style:K},a.createElement("div",{ref:q,style:Q},a.createElement("div",{ref:R,className:n,style:r,children:e})))):null==(i=D.current)||i.render(a.createElement("div",{ref:R,style:K,className:n,children:e}))});let ee=a.useRef(!0);(0,c.A)(e=>{if(L.current){V.updateMatrixWorld(),L.current.updateWorldMatrix(!0,!1);let e=y?Y.current:C(L.current,V,A);if(y||Math.abs(G.current-V.zoom)>t||Math.abs(Y.current[0]-e[0])>t||Math.abs(Y.current[1]-e[1])>t){let t=function(e,t){let r=u.setFromMatrixPosition(e.matrixWorld),n=d.setFromMatrixPosition(t.matrixWorld),i=r.sub(n),o=t.getWorldDirection(m);return i.angleTo(o)>Math.PI/2}(L.current,V),r=!1;J&&(Array.isArray(M)?r=M.map(e=>e.current):"blending"!==M&&(r=[k]));let n=ee.current;if(r){let e=function(e,t,r,n){let i=u.setFromMatrixPosition(e.matrixWorld),o=i.clone();o.project(t),r.setFromCamera(o,t);let a=r.intersectObjects(n,!0);if(a.length){let e=a[0].distance,t=i.distanceTo(r.ray.origin);return t<e}return!0}(L.current,V,I,r);ee.current=e&&!t}else ee.current=!t;n!==ee.current&&(j?j(!ee.current):H.style.display=ee.current?"block":"none");let i=Math.floor(W[0]/2),o=M?J?[W[0],i]:[i-1,0]:W;if(H.style.zIndex=`${function(e,t,r){if(t instanceof l.PerspectiveCamera||t instanceof l.OrthographicCamera){let n=u.setFromMatrixPosition(e.matrixWorld),i=d.setFromMatrixPosition(t.matrixWorld),o=n.distanceTo(i),a=(r[1]-r[0])/(t.far-t.near),s=r[1]-a*t.far;return Math.round(a*o+s)}}(L.current,V,o)}`,y){let[e,t]=[A.width/2,A.height/2],r=V.projectionMatrix.elements[5]*t,{isOrthographicCamera:n,top:i,left:o,bottom:a,right:s}=V,l=x(V.matrixWorldInverse),c=n?`scale(${r})translate(${epsilon(-(s+o)/2)}px,${epsilon((i+a)/2)}px)`:`translateZ(${r}px)`,u=L.current.matrixWorld;b&&((u=V.matrixWorldInverse.clone().transpose().copyPosition(u).scale(L.current.scale)).elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),H.style.width=A.width+"px",H.style.height=A.height+"px",H.style.perspective=n?"":`${r}px`,Z.current&&q.current&&(Z.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,q.current.style.transform=f(u,1/((v||10)/400)))}else{let t=void 0===v?1:function(e,t){if(t instanceof l.OrthographicCamera)return t.zoom;if(!(t instanceof l.PerspectiveCamera))return 1;{let r=u.setFromMatrixPosition(e.matrixWorld),n=d.setFromMatrixPosition(t.matrixWorld),i=t.fov*Math.PI/180,o=r.distanceTo(n);return 1/(2*Math.tan(i/2)*o)}}(L.current,V)*v;H.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}Y.current=e,G.current=V.zoom}}if(!J&&X.current&&!B.current){if(y){if(Z.current){let e=Z.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){let{isOrthographicCamera:t}=V;if(t||S)N.scale&&(Array.isArray(N.scale)?N.scale instanceof l.Vector3?X.current.scale.copy(N.scale.clone().divideScalar(1)):X.current.scale.set(1/N.scale[0],1/N.scale[1],1/N.scale[2]):X.current.scale.setScalar(1/N.scale));else{let t=(v||10)/400,r=e.clientWidth*t,n=e.clientHeight*t;X.current.scale.set(r,n,1)}B.current=!0}}}else{let t=H.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){let e=1/O.factor,r=t.clientWidth*e,n=t.clientHeight*e;X.current.scale.set(r,n,1),B.current=!0}X.current.lookAt(e.camera.position)}}});let et=a.useMemo(()=>({vertexShader:y?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[y]);return a.createElement("group",(0,o.Z)({},N,{ref:L}),M&&!J&&a.createElement("mesh",{castShadow:P,receiveShadow:w,ref:X},S||a.createElement("planeGeometry",null),E||a.createElement("shaderMaterial",{side:l.DoubleSide,vertexShader:et.vertexShader,fragmentShader:et.fragmentShader})))})},8429:function(e,t,r){Promise.resolve().then(r.bind(r,8393))},8393:function(e,t,r){"use strict";r.r(t),r.d(t,{default:function(){return MatrixTranslationPage}});var n=r(9634),i=r(8081),o=r(3156),a=r(9053),s=r(5139),l=r(8967),c=r(9039),u=r(748),d=r(3786),m=r(3813),x=r(8590),f=r.n(x),h=r(4979),p=r(2985),g=r(4612),v=r(2905),b=r(2036);let Cube=e=>{let{position:t,portal:r}=e,i=(0,h.useRef)(),o=t.map(e=>(0,g.NM)(e));return(0,n.jsx)(n.Fragment,{children:(0,n.jsxs)("group",{ref:i,position:[t[0],t[1],t[2]],children:[(0,n.jsx)(v.xu,{args:[5,5,5],children:(0,n.jsx)("meshStandardMaterial",{color:"orange"})}),(0,n.jsx)(v.Cd,{args:[.1],children:(0,n.jsx)(b.V,{center:!0,portal:r,zIndexRange:[1,0],children:(0,n.jsx)("div",{className:"rounded-md bg-neutral-800 p-1 py-2 text-neutral-200",children:(0,n.jsx)(a.Y,{text:"\\begin{pmatrix} ".concat(o[0],", \\ ").concat(o[1],", \\ ").concat(o[2]," \\end{pmatrix}")})})})})]})})};var y=r(3522);let M=(0,y.Ue)(e=>({origin:[0,0,0],position:[0,0,0],setPosition:t=>e(()=>({position:t})),setOrigin:t=>e(()=>({origin:t}))})),j=f()(()=>r.e(686).then(r.bind(r,3588)).then(e=>e.View),{loadableGenerated:{webpack:()=>[3588]},ssr:!1,loading:()=>(0,n.jsx)(i.a,{})}),useTranslationControls=()=>{let[e,t]=M(e=>[e.setPosition,e.setOrigin]),{origin:r,position:n}=(0,m.M4)({origin:{value:[-10,0,0],step:.1,min:-10,max:10},position:{value:[10,0,0],step:.1,min:-10,max:10}});(0,h.useEffect)(()=>{t(r)},[r,t]),(0,h.useEffect)(()=>{e(n)},[n,e])};function MatrixTranslationPage(){let[e,t]=M(e=>[e.position,e.origin]),r=(0,h.useMemo)(()=>{let r=new p.Vector3,n=new p.Vector3,i=new p.Vector3;return r.set(e[0],e[1],e[2]),n.set(t[0],t[1],t[2]),i.subVectors(r,n),i.toArray()},[e,t]),i=e.map(e=>e.toFixed(1)),m=t.map(e=>e.toFixed(1)),x=r.map(e=>e.toFixed(1));useTranslationControls();let f=(0,h.useRef)();return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)("div",{className:"relative",ref:f}),(0,n.jsxs)(j,{className:"relative left-0 top-0 h-full w-full",index:0,track:f,orbit:!0,children:[(0,n.jsx)(Cube,{id:"pre-transform",position:t,portal:f}),(0,n.jsx)(Cube,{id:"post-transform",position:e,portal:f}),(0,n.jsx)("group",{children:(0,n.jsx)(d.x,{points:[t,e],color:"orange"})}),(0,n.jsx)(o.G,{})]}),(0,n.jsx)("div",{className:"fixed left-0 top-10 z-10 w-screen pl-80",children:(0,n.jsxs)(s.W,{p:"4",children:[(0,n.jsxs)(l.X,{size:"4",weight:"light",children:["A Translation Matrix is a 4x4 matrix used in 3D graphics to represent the transformation of an object's position in space.",(0,n.jsx)("br",{}),"It describes how much the object has to move from its original position along the x, y, and z axes.",(0,n.jsx)("br",{}),"The translation matrix is applied to the object's coordinates, resulting in a new position relative to its original location."]}),(0,n.jsx)(c.$,{size:"1",mt:"2",className:"flex items-center justify-center",children:(0,n.jsx)(a.Y,{className:"select-none",text:"p^{\\prime} = \\begin{bmatrix} ".concat(e[0].toFixed(1)," \\\\ ").concat(i[1]," \\\\ ").concat(i[2]," \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 & 0 & 0 & ").concat(x[0]," \\\\ 0 & 1 & 0 & ").concat(x[1]," \\\\ 0 & 0 & 1 & ").concat(x[2]," \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} \\begin{bmatrix} ").concat(m[0]," \\\\ ").concat(m[1]," \\\\ ").concat(m[2]," \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} ").concat(m[0]," + ").concat(x[0]," \\\\ ").concat(m[1]," + ").concat(x[1]," \\\\ ").concat(m[2]," + ").concat(x[2]," \\\\ 1 \\end{bmatrix}")})})]})}),(0,n.jsx)("div",{className:"fixed bottom-10 left-0 z-10 w-screen pl-80",children:(0,n.jsx)(c.$,{p:"6",children:(0,n.jsx)(u.V,{children:"Feel free to explore the impact of different origin and position values by adjusting them, and observe how the translation matrix dynamically transforms the object's position in the 3D space."})})})]})}},4612:function(e,t,r){"use strict";r.d(t,{NM:function(){return round},W$:function(){return normalise},uR:function(){return radians}});let round=e=>Math.round(e).toFixed(1),normalise=e=>{let[t,r,n]=e,i=Math.sqrt(t*t+r*r+n*n);return 0==i?[0,0,0]:[t/i,r/i,n/i]},radians=e=>e*Math.PI/180}},function(e){e.O(0,[252,545,197,391,367,351,657,739,594,904,726,744],function(){return e(e.s=8429)}),_N_E=e.O()}]);